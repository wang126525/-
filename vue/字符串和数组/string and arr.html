<script type="text/javascript">
//Array
//1.定义新的数组
//var arr = new Array();
//console.log(arr);

//var arr = new Array(2);
//console.log(arr.length);
//console.log(arr)
//var arr = Array(2);

//Array构造函数有一个很大的问题，就是不同的参数，会导致它的行为不一致。
//
//new Array() // 
//
////var arr = new Array(1) // 
//var arr = new Array(2) //
//
//var arr = new Array(3.2) 
//var arr = new Array(-3) 
//
//var arr = new Array('abc') 
//var arr = new Array([1]) 
//
//var arr = new Array(1, 2) 
//var arr = new Array('a', 'b', 'c') 
//console.log(arr);

//常用方法（good）
//var arr = [1,2,3,4];

//判断是否为数组
//var a = [1, 2, 3];
//console.log(typeof a); 
//console.log(Array.isArray(a))

//数组实例方法

//valueof()
//var a = [1, 2, 3];
//console.log(a.valueOf())

//tostring();
//var a = [1, 2, 3];
//console.log(a.toString());
//var a = [1, 2, 3, [4, 5, 6]];
//console.log(a.toString())

//利用push合并两数组
//var a = [1, 2, 3];
//var b = [4, 5, 6];
//a.push.apply(a, b)
//console.log(a);

//利用push向对象添加
//var a = {a: 1};
//[].push.call(a, 2);
//console.log(a);
//
//[].push.call(a, [3]);
//console.log(a)

//join
//var a = [1, 2, 3, 4];
//console.log(a.join(' ')) 
//console.log(a.join(' | '))

//[undefined, null].join('#')
//console.log([undefined, null].join('#'))
//
//['a',, 'b'].join('-')
//console.log(['a',, 'b'].join('-'))

//contact
//var arr = ['hello'];
//var arr0 = arr.concat(['world'], ['!']);
//console.log(arr);
//console.log(arr0);

//[1, 2, 3].concat(4, 5, 6)
//// [1, 2, 3, 4, 5, 6]
//
//// 等同于
//[1, 2, 3].concat(4, [5, 6])
//[1, 2, 3].concat([4], [5, 6])

//var obj = { a:1 };
//var oldArray = [obj];
//console.log(oldArray);
//var newArray = oldArray.concat();
//console.log(newArray);
//obj.a = 2;
//newArray[0].a;

//shift()
//var a = ['a', 'b', 'c'];
//console.log(a.shift());

//var list = [1, 2, 3, 4, 5, 6];
//var item;
//
//while (item = list.shift()) {
//console.log(item);
//}


//unshift()
/*var a = ['a', 'b', 'c'];
a.unshift('x'); 
console.log(a.length);
console.log(a);*/

//var arr = [ 'c', 'd' ];
//arr.unshift('a', 'b') // 4
//console.log(arr);

//reverse()
//var a = ['a', 'b', 'c'];
//console.log(a.reverse())


//slice()
// 用法
//var a = ['a', 'b', 'c'];
//console.log(a.slice(0))
//console.log(a.slice(1))
//console.log(a.slice(1, 2) )
//console.log(a.slice(2, 6))
//console.log(a.slice())

//var a = ['a', 'b', 'c'];
//console.log(a.slice(-2))
//console.log(a.slice(-2, -1))

//var a = ['a', 'b', 'c'];
//console.log(a.slice(4))
//console.log(a.slice(2, 1))

//var a = ['a', 'b', 'c', 'd', 'e', 'f'];
//a.splice(4, 2);//代表的是删掉的元素
//console.log(a);
//var b = a.splice(4, 2, 1, 1);
//console.log(b)
//console.log(a);
//
//var a = ['a', 'b', 'c', 'd', 'e', 'f'];
//a.splice(-4, 2) // ["c", "d"]
//上面代码表示，从倒数第四个位置c开始删除两个成员。

//插入元素
//var a = [1, 1, 1];
//a.splice(1, 0, 2);
//console.log(a);

//var a = [1, 2, 3, 4];
//console.log(a.splice(2)) 
//console.log(a);

//console.log(['d', 'c', 'b', 'a'].sort())
//// ['a', 'b', 'c', 'd']
//
//console.log([4, 3, 2, 1].sort());
//// [1, 2, 3, 4]
//
//sort()
////sort方法不是按照大小排序，而是按照对应字符串的字典顺序排序。也就是说，数值会被先转成字符串，再按照字典顺序进行比较，所以101排在11的前面。

//console.log([11, 101].sort());
//// [101, 11]
//console.log([10111, 1101, 111].sort())

//var arr = [10111, 1101, 111].sort(function (a, b) {
//return a - b;
//})
//var arr0 = [10111, 1101, 111].sort(function (a, b) {
//return b - a;
//})
//console.log(arr,arr0);

//map()
//var numbers = [1, 2, 3];
//var number = numbers.map(function (n) {
//return n + 1;
//});
//////返回一个新数组
//console.log(numbers)
//console.log(number);

//var num = [1, 2, 3].map(function(elem, index, arr) {
//return elem * index;
////返回一个新数组[1*0，2*1，3*2]
//});
//console.log(num);


//forEach()
//function log(element, index, array) {
//console.log('[' + index + '] = ' + element);
//}
//[2, 5, 9].forEach(log)

//var out = [];
//[1, 2, 3].forEach(function(elem) {
//this.push(elem * elem);
//}, out);
//console.log(out);

//var obj = {
//name: '张三',
//times: [1, 2, 3],
//print: function () {
//  this.times.forEach(function (n) {
//    console.log(this.name);
//  });
//}
//};
//obj.print()
//上面代码中，obj.print方法有两层this，它们的指向是不一致的。外层的this.times指向obj对象，内层的this.name指向顶层对象window（详细解释参见《面向对象编程》一章）。这显然是违背原意的，解决方法就是使用forEach方法的第二个参数固定this

//var obj = {
//0: 1,
//a: 'hello',
//length: 1
//}

//Array.prototype.forEach.call(obj, function (elem, i) {
//console.log( i + ':' + elem);
//});
//// 0:1
//
//var str = 'hello';
//Array.prototype.forEach.call(str, function (elem, i) {
//console.log( i + ':' + elem);
//});
//obj是一个类似数组的对象，forEach方法可以遍历它的数字键。forEach方法也可以遍历字符串。


//filter()
//var arr = [1, 2, 3, 4, 5].filter(function (elem) {
//return (elem > 3);
//})
//console.log(arr);

//var arr = [1, 2, 3, 4, 5].filter(function (elem, index, arr) {
//return index % 2 === 0;
//})
//console.log(arr);

//some()，every()
//var arr = [1, 2, 3, 4, 5];
//console.log(arr.some(function (elem, index, arr) {
//return elem >= 3;
//}))
//var arr0 = [1, 2, 3, 4, 5];
//console.log(arr0.every(function (elem, index, arr) {
//return elem >= 3;
//}))


//stirng
	
// var str = 	'a
//	b
//	c';
//console.log(str);
	
//var longString = "a\
//b\
//c\
//d"
//	console.log(longString);
	
//var str = "ABCDECDF"; 
//console.log(str.lastIndexOf("CD",6)); 
//	
//var str = "ABCDECDF"; 
//console.log(str.search("CD"));
//console.log( str.search(/CD/i))


//var str = "ABC"; 
//console.log(str.charCodeAt(0));
//console.log(String.fromCharCode(65,66,112))

//var str = "ABC"; 
//console.log(str.charAt(1));

//var str = "ABCDEF"; 
//console.log(str.slice(2,4))

//var str = "ABCDEF"; 
//console.log(str.substr(2,4))

//var str = "ABCDECDF"; 
//console.log(str.lastIndexOf("CD",6))

//var str = "ABCDEF"; 
//console.log(str.concat("ABCDEF","ABC"))
//console.log(str);

//var str = "AA BB CC DD EE FF"; 
//console.log(str.split(" ",3))
</script>
